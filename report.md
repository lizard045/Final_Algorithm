# 基於高階蟻群演算法之 DAG 任務排程問題求解報告

## 1. 解題構想

### 1.1 動機與目的

本研究旨在解決異質運算環境下，有相依性的任務集合（以有向無環圖 Directed Acyclic Graph, DAG 表示）的最佳化排程問題。此問題在雲端運算、高效能計算等領域至關重要，其目標是將所有任務分配到最適合的處理器上，並決定執行順序，以最小化整體完工時間（Makespan）。

由於此問題已被證明為 NP-hard，傳統的確定性演算法難以在合理時間內找到最佳解。因此，本研究選用 **蟻群演算法 (Ant Colony Optimization, ACO)** 作為求解元啟發式演算法。ACO 模擬自然界中螞蟻尋找食物的集體智慧行為，透過正向回饋機制（費洛蒙）來引導搜尋方向，使其非常適合解決組合最佳化問題。

### 1.2 演算法優點

本研究不僅採用了基礎的 ACO，而是實作了一個結合多種先進策略的 **高階混合蟻群演算法**，使其具備以下優點：

1.  **強大的探索與利用平衡機制:** 演算法融合了 **最大最小螞蟻系統 (Max-Min Ant System, MMAS)**，透過設定費洛蒙的上下限 (`tau_max`, `tau_min`)，有效避免了搜尋過早停滯於局部最佳解。同時，採用 **偽隨機比例規則 (Pseudo-random Proportional Rule)**，允許演算法在「貪婪地利用已知最佳路徑」和「機率性地探索新路徑」之間進行動態切換。

2.  **高效的啟發式資訊:** 演算法在指導螞蟻決策時，不僅考慮了任務的 **最早完成時間 (Earliest Finish Time, EFT)**，還整合了 **向上排名 (Upward Rank)**。這種複合式啟發資訊，讓螞蟻的決策兼顧了「短期效益」（選擇能最快完成的任務）與「長期策略」（優先處理位於關鍵路徑上的任務），大幅提升了找到高品質解的機率。

3.  **先進的停滯處理與重啟策略:** 演算法設計了精密的多層次停滯處理機制。當偵測到搜尋停滯時，會先透過調整參數、強制多樣性等「軟重啟」策略嘗試跳出局部最優。若停滯持續，則會採取更激進的「硬重啟」策略，對當前最佳解進行 **突變 (Mutation)** 並重置費洛蒙，引導搜尋到全新的區域，顯著增強了演算法的廣域搜尋能力。

4.  **計算資源的有效利用:** 透過引入 **局部搜尋 (Local Search)** 機制，對有潛力的新最佳解進行精煉。但此搜尋並非盲目地應用於所有解，而是僅在當代螞蟻找到的新解優於全域最佳解時才觸發，從而在不犧牲解的品質下，大幅降低了計算成本。

## 2. 問題編碼方式

### 2.1 解的表示方法 (Solution Representation)

一個完整的排程方案（解）由兩個核心部分組成，共同定義了所有任務的分配與執行順序：

1.  **處理器分配陣列 (`processorAssignments`):**
    這是一個一維整數陣列，其索引代表任務的 ID，陣列中的值則代表該任務被分配到的處理器 ID。
    *   **格式:** `int[taskCount]`
    *   **範例:** `processorAssignments[4] = 2` 表示將 ID 為 4 的任務分配給 ID 為 2 的處理器執行。

2.  **任務排程順序列表 (`constructedTaskOrder`):**
    這是一個記錄任務被排程順序的列表。這個順序是根據演算法的決策過程動態建立的，並天然地滿足了 DAG 的任務相依性。
    *   **格式:** `List<Integer>`
    *   **範例:** `[0, 2, 1, 3, 4, ...]` 表示任務 0 最先被排程，其次是任務 2，接著是任務 1，依此類推。

**舉例說明:**
假設我們有一個包含 5 個任務和 3 個處理器的問題。一個可能的解可以表示如下：
*   `processorAssignments = {0, 1, 0, 2, 1}`
    *   任務0 -> 處理器0
    *   任務1 -> 處理器1
    *   任務2 -> 處理器0
    *   任務3 -> 處理器2
    *   任務4 -> 處理器1
*   `constructedTaskOrder = {0, 2, 1, 3, 4}`

這個編碼方式清晰地定義了一個完整的排程方案，可以直接用於評估。

### 2.2 評估函式 (Evaluation Function)

本演算法的最終評估指標，也是最佳化目標，是 **整體完工時間 (Makespan)**。Makespan 被定義為 **最後一個完成的任務的完成時間**。評估函式的計算過程如下：

1.  根據 `processorAssignments` 和 `constructedTaskOrder`，模擬執行整個排程。
2.  對於每一個任務，其 **最早開始時間 (Earliest Start Time, EST)** 取決於以下兩者中的最大值：
    *   其被分配到的處理器的可用時間 (Processor Ready Time)。
    *   其所有前驅任務的資料傳輸到該處理器的最晚到達時間。
3.  任務的 **完成時間 (Finish Time, FT)** 為 `EST + 執行時間`。
4.  所有任務的 FT 計算完畢後，取其中 **最大的一個 FT 值**，即為此排程解的 Makespan。

我們的目標就是找到一個解，使其 Makespan 最小。

## 3. 設計方法

### 3.1 演算法流程

本演算法的執行流程可以透過以下活動圖來描述，其中特別強調了停滯處理等創新之處：

```mermaid
graph TD
    A[開始] --> B{初始化};
    B --> B1[載入 DAG 問題];
    B1 --> B2[使用 PEFT 預估 Makespan];
    B2 --> B3[計算 MMAS 參數 tau_max, tau_min];
    B3 --> B4[初始化費洛蒙矩陣];
    B4 --> C{For each Generation};
    C --> D[螞蟻建構解];
    D -- 為每隻螞蟻 -->> D1{選擇 (任務,處理器) Pair};
    D1 -- 偽隨機比例規則 -->> D2[計算 Desirability<br>(Pheromone, Heuristic)];
    D2 --> D1;
    D1 -- 所有任務排程完畢 -->> D3[產生完整 Schedule];
    D3 --> E[評估所有螞蟻的解 (Makespan)];
    
    E --> F{找到新的全域最佳解?};
    F -- Yes --> G[對新最佳解進行局部搜尋精煉];
    G --> G1[更新全域最佳解];
    G1 --> H{更新費洛蒙};
    F -- No --> H;

    H --> I{偵測停滯};
    I -- No --> J[更新迭代數據];
    I -- Yes --> K{停滯處理};
    K -- 軟停滯 --> K1[降低 q0<br>增加探索];
    K1 --> J;
    K -- 硬停滯 --> K2[突變最佳解<br>重置費洛蒙];
    K2 --> J;

    J --> L{達到終止條件?};
    L -- No --> C;
    L -- Yes --> M[輸出最佳排程解];
    M --> Z[結束];

    subgraph 螞蟻決策核心
        D1
        D2
    end
    
    subgraph 創新點: 停滯處理
        I
        K
        K1
        K2
    end

    style G fill:#d4edda,stroke:#c3e6cb
    style K fill:#fff3cd,stroke:#ffeeba
```

### 3.2 不可行解的處理

本演算法在設計上 **從根本上杜絕了不可行解的出現**。

其核心機制在於 `Ant.java` 中的解建構過程。演算法內部維護一個 **就緒任務列表 (Ready Tasks List)**。一個任務只有在它的所有前驅任務（根據 DAG 定義）都已經被排程完成後，才有資格被加入到這個列表中。

螞蟻在每一步決策時，都只能從這個「就緒任務列表」中選擇任務。這個機制確保了任何被排程的任務，其相依性都已被滿足，從而保證了產生的每一個排程解都是 **100% 可行的 (feasible)**。因此，演算法無需設計額外的機制來懲罰或修復不可行解。

## 4. 實驗設計

演算法在進行實驗時所用的主要參數定義在 `Main.java` 中，其選用理由如下：

| 參數 | 設定值 | 用途與選用理由 |
| :--- | :--- | :--- |
| `NUM_ANTS` | 55 | **螞蟻數量**。設定一個足夠大的群體規模，以確保搜尋空間能被充分探索。55 是一個在群體多樣性和單次迭代計算成本之間的權衡。 |
| `ACO_GENERATIONS` | 200 | **最大迭代次數**。定義演算法的總搜尋時長。200 次迭代為演算法提供了足夠的時間來收斂到一個高品質解。演算法也包含提前終止機制，可能在此之前結束。 |
| `ALPHA` | 1.0 | **費洛蒙影響因子**。控制費洛蒙在螞蟻決策中的權重。設為 1.0 是 ACO 的一個標準起始值，表示不對費洛蒙的影響進行額外的指數縮放。 |
| `BETA` | 2.0 | **啟發式資訊影響因子**。控制啟發式資訊（EFT + Upward Rank）的權重。設為 2.0 表示我們更信任啟發式資訊提供的指引，這在許多排程問題中被證明是有效的。 |
| `EVAPORATION_RATE` | 0.3 | **費洛蒙蒸發率**。控制舊費洛蒙消失的速度，避免演算法過快陷入局部最優。0.3 是一個中等值，允許演算法在遺忘舊路徑和鞏固好路徑之間取得平衡。 |
| `EXPLOITATION_FACTOR_Q0` | 0.8 | **偽隨機比例規則因子**。以 80% 的機率貪婪地選擇當前最佳決策（利用），20% 的機率進行輪盤賭選擇（探索）。此高值設定使演算法在大部分時間內傾向於利用已知的好選擇，同時保留一定的探索能力。此值在運行中會動態調整。 |
| `NUM_RANKED_ANTS` | 6 | **排名螞蟻數量**。在排名式費洛蒙更新中，只有排名前 6 的螞蟻可以釋放費洛蒙。這能確保只有高品質的解才能對後續搜尋產生影響，避免較差的解污染費洛蒙路徑。 |
| `ELITIST_WEIGHT` | 6.0 | **精英螞蟻權重**。全域最佳解（精英螞蟻）在更新費洛蒙時的貢獻權重。較高的權重（6.0）可以強力地引導搜尋方向朝著已知的最佳解周圍探索。 |
| `PHEROMONE_SMOOTHING_FACTOR` | 0.05 | **費洛蒙平滑因子**。此為停滯處理的一部分，用於在需要時重置或調整費洛蒙，避免其值過於極端。 |

## 5. 實驗結果

本章節將您的演算法 (後稱 **MyACO**) 的實驗結果與附圖中提供的六種競爭方法的數據進行比較。

### 5.1 數據整理

首先，整理附圖中的六種方法的實驗數據。

**第一種方法**
| Heterogeneity | Best | Worst | Avg | sd | Avg. Running Time (s) |
|---|---|---|---|---|---|
| 0.0 | 440.0 | 440.0 | 440.0 | 0.00 | 0.4094 |
| 0.2 | 425.1 | 438.8 | 427.8 | 6.12 | 0.4188 |
| 0.4 | 403.3 | 426.3 | 412.3 | 8.88 | 0.3968 |
| 0.6 | 423.2 | 423.2 | 423.2 | 0.00 | 0.4282 |

**第二種方法**
| Heterogeneity | Best | Worst | Avg | sd | Avg. Running Time (s) |
|---|---|---|---|---|---|
| 0.0 | 470.0 | 510.0 | 492.0 | 14.83 | 0.2030 |
| 0.2 | 464.5 | 500.8 | 478.4 | 16.05 | 0.2030 |
| 0.4 | 448.5 | 489.6 | 465.7 | 16.03 | 0.2032 |
| 0.6 | 456.8 | 561.4 | 499.9 | 45.67 | 0.2032 |

**第三種方法**
| Heterogeneity | Best | Worst | Avg | sd | Avg. Running Time (s) |
|---|---|---|---|---|---|
| 0.0 | 440.0 | 460.0 | 450.0 | 10.00 | 1.2372 |
| 0.2 | 425.1 | 435.2 | 429.1 | 4.10 | 1.6094 |
| 0.4 | 410.8 | 431.0 | 421.3 | 8.23 | 1.5470 |
| 0.6 | 416.4 | 435.2 | 426.2 | 7.68 | 1.4342 |

**第四種方法**
| Heterogeneity | Best | Worst | Avg | sd | Avg. Running Time (s) |
|---|---|---|---|---|---|
| 0.0 | 440.0 | 460.0 | 444.0 | 8.94 | 0.5218 |
| 0.2 | 425.1 | 425.1 | 425.1 | 0.00 | 0.7096 |
| 0.4 | 403.3 | 432.5 | 420.4 | 14.11 | 0.6596 |
| 0.6 | 413.8 | 436.6 | 420.2 | 10.01 | 0.5688 |

**第五種方法**
| Heterogeneity | Best | Worst | Avg | sd | Avg. Running Time (s) |
|---|---|---|---|---|---|
| 0.0 | 520.0 | 520.0 | 520.0 | 0.00 | <0.001 |
| 0.2 | 523.2 | 523.2 | 523.2 | 0.00 | <0.001 |
| 0.4 | 495.7 | 495.7 | 495.7 | 0.00 | <0.001 |
| 0.6 | 455.0 | 455.0 | 455.0 | 0.00 | <0.001 |

**第六種方法**
| Heterogeneity | Best | Worst | Avg | sd | Avg. Running Time (s) |
|---|---|---|---|---|---|
| 0.0 | 470.0 | 510.0 | 486.0 | 21.90 | 0.9722 |
| 0.2 | 445.8 | 474.5 | 459.8 | 11.00 | 1.0096 |
| 0.4 | 427.9 | 462.1 | 447.7 | 14.20 | 1.0750 |
| 0.6 | 413.8 | 455.7 | 438.9 | 22.90 | 0.7564 |

### 5.2 效能比較與計分

**比較規則:**
1.  **品質指標 (Makespan):** 對於每一個 Heterogeneity 等級 (0.0, 0.2, 0.4, 0.6)，MyACO 的 **Best, Worst, Avg, sd** 四項指標將與其他六種方法進行比較。MyACO 在某個等級上 **勝出 (Win)**，當且僅當其 **至少在 3 個指標上優於** 對方。（註：對於 Best, Worst, Avg, sd，值越小越好）。
2.  **時間指標 (Avg. Running Time):** 執行時間單獨比較，值越小越好。
3.  **累計分數:** MyACO 每在一個 Heterogeneity 等級的品質指標上勝出，就得 1 分。總分 4 分。

**MyACO 實驗數據 (請填入):**
> **注意:** 請執行 `Main.java`，將得到的 `FINAL EXPERIMENT SUMMARY` 結果填入下表。

| Heterogeneity | Best | Worst | Avg | sd | Avg. Running Time (s) |
|---|---|---|---|---|---|
| 0.0 (n4_00) | ? | ? | ? | ? | ? |
| 0.2 (n4_02) | ? | ? | ? | ? | ? |
| 0.4 (n4_04) | ? | ? | ? | ? | ? |
| 0.6 (n4_06) | ? | ? | ? | ? | ? |

---

**累計分數統計 (請在填入數據後完成分析):**

| 比較對象 | MyACO 總分 (Max 4) | 時間比較 |
| :--- | :--- | :--- |
| **vs. 第一種方法** | ? / 4 | (MyACO 更快/更慢/相當) |
| **vs. 第二種方法** | ? / 4 | (MyACO 更快/更慢/相當) |
| **vs. 第三種方法** | ? / 4 | (MyACO 更快/更慢/相當) |
| **vs. 第四種方法** | ? / 4 | (MyACO 更快/更慢/相當) |
| **vs. 第五種方法** | ? / 4 | (MyACO 更快/更慢/相當) |
| **vs. 第六種方法** | ? / 4 | (MyACO 更快/更慢/相當) |

**結論分析 (範本):**
> (在填寫完表格後，根據結果撰寫)
>
> 從品質指標來看，MyACO 在與六種方法的競爭中，取得了 `X` 次勝利，總分為 `Y` 分。特別是在處理 Heterogeneity 為 `0.X` 的案例時，展現出...的優勢/劣勢。
>
> 從執行效率來看，MyACO 的平均執行時間為 `Z` 秒，相比於...方法有顯著的速度優勢，但慢於...方法。這可能是因為 MyACO 採用了更複雜的停滯處理和局部搜尋機制，用以換取更高的解品質。
>
> 綜合來看，本研究提出的高階混合蟻群演算法在求解品質上具有顯著的競爭力...

### 5.3 收斂曲線

為了視覺化演算法的搜尋過程，應為每個問題案例 (n4_00, n4_02, n4_04, n4_06) 繪製收斂曲線。

**繪製方法:**
1.  執行 `Main.java` 後，程式會在根目錄下產生四個 `.csv` 檔案，例如 `n4_00.dag.convergence.csv`。
2.  每個 CSV 檔案包含兩欄：`Generation` 和 `Makespan`。
3.  使用 Excel, Python (Matplotlib), 或其他繪圖工具，以 `Generation` 為 X 軸，`Makespan` 為 Y 軸，繪製折線圖。

**曲線分析 (範本):**
> (在繪製出圖表後，根據圖形撰寫)
>
> 從收斂曲線圖可以看出，在問題 `n4_00` 中，演算法大約在第 80 代就快速收斂到一個穩定的高品質解，展現了良好的收斂速度。對於複雜度更高的 `n4_06` 問題，曲線顯示演算法在前期快速下降後，在約 120-150 代之間出現了幾個明顯的階梯式下降，這很可能是由於觸發了停滯處理機制，成功跳出局部最優，並找到了更好的解，最終收斂於...。這證明了本演算法的先進停滯處理機制的有效性。 